<?php

namespace PhpMx\Datalayer\Connection;

use Exception;
use PDO;
use PhpMx\Cif;
use PhpMx\Datalayer;
use PhpMx\Datalayer\Query;
use PhpMx\Datalayer\Query\BaseQuery;
use PhpMx\Log;

class Postgresql extends BaseConnection
{
    protected string $pdoDriver = 'pdo_pgsql';

    /** Executa uma query */
    function executeQuery(string|BaseQuery $query, array $data = []): mixed
    {
        if (is_class($query, BaseQuery::class))
            list($query, $data) = $query->query();

        $placeholders = [];
        $query = preg_replace_callback("/'(?:''|[^'])*'/", function ($match) use (&$placeholders) {
            $key = '__LIT' . count($placeholders) . '__';
            $placeholders[$key] = $match[0];
            return $key;
        }, $query);

        $query = preg_replace('/`([^`]+)`/', '"$1"', $query);

        foreach ($placeholders as $key => $value) {
            $query = str_replace($key, $value, $query);
        }

        return parent::executeQuery($query, $data);
    }

    /** Inicializa a conexão */
    protected function load()
    {
        $envName = strtoupper($this->dbName);

        $this->data['host'] = $this->data['host'] ?? env("DB_{$envName}_HOST");
        $this->data['data'] = $this->data['data'] ?? env("DB_{$envName}_DATA");
        $this->data['user'] = $this->data['user'] ?? env("DB_{$envName}_USER");
        $this->data['pass'] = $this->data['pass'] ?? env("DB_{$envName}_PASS");
        $this->data['port'] = $this->data['port'] ?? env("DB_{$envName}_PORT");
        $this->data['scheme'] = $this->data['scheme'] ?? env("DB_{$envName}_SCHEME") ?? 'public';

        if (empty($this->data['port'])) unset($this->data['port']);

        $this->data['pass'] = Cif::off($this->data['pass']);

        $dsn = "pgsql:host={$this->data['host']}";

        if ($this->data['port']) $dsn .= ";port={$this->data['port']}";

        $dsn .= ";dbname={$this->data['data']}";

        $this->instancePDO = [
            $dsn,
            $this->data['user'],
            $this->data['pass'],
            $this->data['scheme']
        ];
    }

    /** Retorna a instancia PDO da conexão */
    protected function &pdo(): \PDO
    {
        if (is_array($this->instancePDO)) {
            Log::add('datalayer.start', prepare('[#] postgresql', Datalayer::externalName($this->dbName, 'Db')), function () {
                $scheme = array_pop($this->instancePDO);
                $this->instancePDO = new \PDO(...$this->instancePDO);
                $this->instancePDO->exec("SET search_path TO $scheme");
            });
        }
        return $this->instancePDO;
    }

    /** Carrega as configurações do banco armazenadas na tabela __config */
    protected function loadConfig(): void
    {
        if (!$this->config) {
            $this->config = [];

            $configTableExistsQuery = Query::select('information_schema.tables')
                ->where('table_schema', 'public')
                ->where('table_name', '__config')
                ->limit(1);

            if (!count($this->executeQuery($configTableExistsQuery))) {
                $this->executeQuery('CREATE TABLE "__config" ("id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, "name" VARCHAR(100) NOT NULL UNIQUE, "value" TEXT NOT NULL);');
            }

            foreach ($this->executeQuery(Query::select('__config')) as $config) {
                $this->config[$config['name']] = is_serialized($config['value'])
                    ? unserialize($config['value'])
                    : $config['value'];
            }
        }
    }

    /** Query para criação de tabelas */
    protected function schemeQueryCreateTable(string $tableName, ?string $comment, array $fields): array
    {
        $queryFields = ['id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY'];
        $queries = [];

        foreach ($fields['add'] ?? [] as $fieldName => $field) {
            if ($field) {
                $queryFields[] = $this->schemeTemplateField($fieldName, $field);

                if (!empty($field['comment'])) {
                    $queries[] = prepare(
                        'COMMENT ON COLUMN "[#table]"."[#field]" IS \'[#comment]\';',
                        [
                            'table' => $tableName,
                            'field' => $fieldName,
                            'comment' => $field['comment']
                        ]
                    );
                }
            }
        }

        array_unshift($queries, prepare('CREATE TABLE "[#name]" ([#fields]);', [
            'name' => $tableName,
            'fields' => implode(', ', $queryFields),
        ]));

        if ($comment) {
            $queries[] = prepare('COMMENT ON TABLE "[#name]" IS \'[#comment]\';', [
                'name' => $tableName,
                'comment' => $comment,
            ]);
        }

        return $queries;
    }

    /** Query para alteração de tabelas */
    protected function schemeQueryAlterTable(string $tableName, ?string $comment, array $fields): array
    {
        $query = [];

        if (!is_null($comment)) {
            $query[] = prepare('COMMENT ON TABLE "[#table]" IS \'[#comment]\';', [
                'table' => $tableName,
                'comment' => $comment
            ]);
        }

        foreach ($fields['add'] as $fieldName => $fieldData) {
            $query[] = prepare('ALTER TABLE "[#table]" ADD COLUMN [#fieldQuery];', [
                'table' => $tableName,
                'fieldQuery' => $this->schemeTemplateField($fieldName, $fieldData)
            ]);

            if (!empty($fieldData['comment'])) {
                $query[] = prepare('COMMENT ON COLUMN "[#table]"."[#field]" IS \'[#comment]\';', [
                    'table' => $tableName,
                    'field' => $fieldName,
                    'comment' => $fieldData['comment']
                ]);
            }
        }

        foreach ($fields['drop'] as $fieldName => $fieldData) {
            $query[] = prepare('ALTER TABLE "[#table]" DROP COLUMN "[#fieldName]";', [
                'table' => $tableName,
                'fieldName' => $fieldName
            ]);
        }

        foreach ($fields['alter'] as $fieldName => $fieldData) {
            $query[] = prepare('ALTER TABLE "[#table]" ALTER COLUMN "[#fieldName]" TYPE [#type];', [
                'table' => $tableName,
                'fieldName' => $fieldName,
                'type' => $this->schemeTemplateFieldTypeOnly($fieldData)
            ]);

            if (array_key_exists('null', $fieldData)) {
                $query[] = prepare('ALTER TABLE "[#table]" ALTER COLUMN "[#fieldName]" [#nullAction];', [
                    'table' => $tableName,
                    'fieldName' => $fieldName,
                    'nullAction' => $fieldData['null'] ? 'DROP NOT NULL' : 'SET NOT NULL'
                ]);
            }

            if (array_key_exists('default', $fieldData)) {
                $query[] = prepare('ALTER TABLE "[#table]" ALTER COLUMN "[#fieldName]" SET DEFAULT [#default];', [
                    'table' => $tableName,
                    'fieldName' => $fieldName,
                    'default' => $this->formatDefault($fieldData['default'])
                ]);
            }

            if (!empty($fieldData['comment'])) {
                $query[] = prepare('COMMENT ON COLUMN "[#table]"."[#field]" IS \'[#comment]\';', [
                    'table' => $tableName,
                    'field' => $fieldName,
                    'comment' => $fieldData['comment']
                ]);
            }
        }

        return $query;
    }

    /** Query para remoção de tabelas */
    protected function schemeQueryDropTable(string $tableName): array
    {
        return [prepare('DROP TABLE IF EXISTS "[#name]";', ['name' => $tableName])];
    }

    /** Retorna somente o tipo de dado PostgreSQL correspondente ao campo */
    protected static function schemeTemplateFieldTypeOnly(array $field): string
    {
        return match ($field['type']) {
            'int', 'idx', 'time', 'boolean' => "INTEGER",
            'float' => "REAL",
            'string', 'email', 'md5', 'mx5' => "VARCHAR({$field['size']})",
            'text', 'json' => "TEXT",
            default => throw new Exception("Type [$field[type]] not suported")
        };
    }

    /** Query para atualização de index */
    protected function schemeQueryUpdateTableIndex(string $name, array $index): array
    {
        $query = [];

        foreach ($index as $indexName => $scheme) {
            $quotedIndex = "\"{$name}_{$indexName}\"";

            if ($scheme) {
                [$field, $unique] = $scheme;
                $quotedField = "\"$field\"";
                $query[] = $unique
                    ? "CREATE UNIQUE INDEX $quotedIndex ON \"$name\" ($quotedField);"
                    : "CREATE INDEX $quotedIndex ON \"$name\" ($quotedField);";
            } else {
                $query[] = "DROP INDEX IF EXISTS $quotedIndex;";
            }
        }

        return $query;
    }

    /** Retorna o template do campo para composição de querys */
    protected static function schemeTemplateField(string $fieldName, array $field): string
    {
        $field['name'] = $fieldName;
        $field['null'] = $field['null'] ? '' : ' NOT NULL';

        switch ($field['type']) {
            case 'idx':
            case 'time':
            case 'int':
            case 'boolean':
                $field['type'] = 'INTEGER';
                break;

            case 'float':
                $field['type'] = 'REAL';
                break;

            case 'text':
            case 'json':
                $field['type'] = 'TEXT';
                break;

            case 'string':
            case 'email':
            case 'md5':
            case 'mx5':
                $field['type'] = "VARCHAR({$field['size']})";
                break;

            default:
                throw new Exception("Type [$field[type]] not suported");
        }

        $field['default'] = is_null($field['default']) ? '' : ' DEFAULT ' . self::formatDefault($field['default']);

        return prepare('"[#name]" [#type][#default][#null]', $field);
    }

    /** Formata o valor default corretamente para PostgreSQL */
    protected static function formatDefault(mixed $value): string
    {
        if (is_null($value)) return 'NULL';
        if (is_bool($value)) return $value ? 'TRUE' : 'FALSE';
        if (is_numeric($value)) return $value;
        return "'" . str_replace("'", "''", $value) . "'";
    }
}
